/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.2.0 (NJsonSchema v10.0.24.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IBondsClient {
    bonds(customerId: string | undefined): Observable<BondVm>;
    createBond(command: CreateBondCommand): Observable<string>;
    bondMaxIdByCustomerId(customerId: string | undefined): Observable<number>;
    bondByCustomerIdAndBondCustomerIdQuery(customerId: string, bondUserId: number, finYear: number): Observable<BondDailyTransactionDto>;
    updateBond(id: string, command: UpdateBondCommand): Observable<FileResponse>;
    deleteBond(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class BondsClient implements IBondsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    bonds(customerId: string | undefined): Observable<BondVm> {
        let url_ = this.baseUrl + "/api/Bonds?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBonds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBonds(<any>response_);
                } catch (e) {
                    return <Observable<BondVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<BondVm>><any>_observableThrow(response_);
        }));
    }

    protected processBonds(response: HttpResponseBase): Observable<BondVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BondVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BondVm>(<any>null);
    }

    createBond(command: CreateBondCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Bonds";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBond(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBond(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    bondMaxIdByCustomerId(customerId: string | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Bonds/BondMaxIdByCustomerId?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBondMaxIdByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBondMaxIdByCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processBondMaxIdByCustomerId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    bondByCustomerIdAndBondCustomerIdQuery(customerId: string, bondUserId: number, finYear: number): Observable<BondDailyTransactionDto> {
        let url_ = this.baseUrl + "/api/Bonds/BondByCustomerIdAndBondCustomerIdQuery/{customerId}/{bondUserId}/{finYear}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        if (bondUserId === undefined || bondUserId === null)
            throw new Error("The parameter 'bondUserId' must be defined.");
        url_ = url_.replace("{bondUserId}", encodeURIComponent("" + bondUserId)); 
        if (finYear === undefined || finYear === null)
            throw new Error("The parameter 'finYear' must be defined.");
        url_ = url_.replace("{finYear}", encodeURIComponent("" + finYear)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBondByCustomerIdAndBondCustomerIdQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBondByCustomerIdAndBondCustomerIdQuery(<any>response_);
                } catch (e) {
                    return <Observable<BondDailyTransactionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BondDailyTransactionDto>><any>_observableThrow(response_);
        }));
    }

    protected processBondByCustomerIdAndBondCustomerIdQuery(response: HttpResponseBase): Observable<BondDailyTransactionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BondDailyTransactionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BondDailyTransactionDto>(<any>null);
    }

    updateBond(id: string, command: UpdateBondCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Bonds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBond(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBond(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteBond(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Bonds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBond(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBond(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBond(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICustomersClient {
    customers(): Observable<CustomerVm>;
    createCustomer(command: CreateCustomerCommand): Observable<string>;
    customersLov(): Observable<CustomerLovVm>;
    deleteCustomer(id: string): Observable<FileResponse>;
    updateCustomer(id: string, command: UpdateCustomerCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    customers(): Observable<CustomerVm> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomers(<any>response_);
                } catch (e) {
                    return <Observable<CustomerVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerVm>><any>_observableThrow(response_);
        }));
    }

    protected processCustomers(response: HttpResponseBase): Observable<CustomerVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerVm>(<any>null);
    }

    createCustomer(command: CreateCustomerCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateCustomer(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    customersLov(): Observable<CustomerLovVm> {
        let url_ = this.baseUrl + "/api/Customers/CustomersLov";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCustomersLov(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCustomersLov(<any>response_);
                } catch (e) {
                    return <Observable<CustomerLovVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerLovVm>><any>_observableThrow(response_);
        }));
    }

    protected processCustomersLov(response: HttpResponseBase): Observable<CustomerLovVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerLovVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerLovVm>(<any>null);
    }

    deleteCustomer(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCustomer(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateCustomer(id: string, command: UpdateCustomerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomer(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCustomer(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IDailyTransactionsClient {
    createDailyTransaction(command: CreateDailyTransactionCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class DailyTransactionsClient implements IDailyTransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    createDailyTransaction(command: CreateDailyTransactionCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/DailyTransactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDailyTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDailyTransaction(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDailyTransaction(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IDetailAccountsClient {
    detailAccounts(customerId: string | undefined): Observable<DetailAccountVm>;
    maxDetailAccountIdByCustomer(customerId: string, id: number): Observable<number>;
    detailAccount(customerId: string | undefined, detailAccountIdByCustomer: number | undefined): Observable<DetailAccountDetailsVm>;
    createDetailAccount(command: CreateDetailAccountCommand): Observable<string>;
    updateDetailAccount(id: string, command: UpdateDetailAccountCommand): Observable<FileResponse>;
    deleteDetailAccount(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DetailAccountsClient implements IDetailAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    detailAccounts(customerId: string | undefined): Observable<DetailAccountVm> {
        let url_ = this.baseUrl + "/api/DetailAccounts/customerId?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailAccounts(<any>response_);
                } catch (e) {
                    return <Observable<DetailAccountVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DetailAccountVm>><any>_observableThrow(response_);
        }));
    }

    protected processDetailAccounts(response: HttpResponseBase): Observable<DetailAccountVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailAccountVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DetailAccountVm>(<any>null);
    }

    maxDetailAccountIdByCustomer(customerId: string, id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/DetailAccounts/{customerId}/{id}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaxDetailAccountIdByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxDetailAccountIdByCustomer(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxDetailAccountIdByCustomer(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    detailAccount(customerId: string | undefined, detailAccountIdByCustomer: number | undefined): Observable<DetailAccountDetailsVm> {
        let url_ = this.baseUrl + "/api/DetailAccounts?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        if (detailAccountIdByCustomer === null)
            throw new Error("The parameter 'detailAccountIdByCustomer' cannot be null.");
        else if (detailAccountIdByCustomer !== undefined)
            url_ += "detailAccountIdByCustomer=" + encodeURIComponent("" + detailAccountIdByCustomer) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDetailAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDetailAccount(<any>response_);
                } catch (e) {
                    return <Observable<DetailAccountDetailsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<DetailAccountDetailsVm>><any>_observableThrow(response_);
        }));
    }

    protected processDetailAccount(response: HttpResponseBase): Observable<DetailAccountDetailsVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DetailAccountDetailsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DetailAccountDetailsVm>(<any>null);
    }

    createDetailAccount(command: CreateDetailAccountCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/DetailAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDetailAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDetailAccount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDetailAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    updateDetailAccount(id: string, command: UpdateDetailAccountCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DetailAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDetailAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDetailAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDetailAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteDetailAccount(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/DetailAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDetailAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDetailAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDetailAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFinanceYearsClient {
    financeYears(): Observable<FinanceYearVm>;
    createFinanceYear(command: CreateFinanceYearCommand): Observable<string>;
    updateFinanceYear(id: string, command: UpdateFinanceYearCommand): Observable<FileResponse>;
    deleteFinanceYear(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FinanceYearsClient implements IFinanceYearsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    financeYears(): Observable<FinanceYearVm> {
        let url_ = this.baseUrl + "/api/FinanceYears";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinanceYears(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinanceYears(<any>response_);
                } catch (e) {
                    return <Observable<FinanceYearVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<FinanceYearVm>><any>_observableThrow(response_);
        }));
    }

    protected processFinanceYears(response: HttpResponseBase): Observable<FinanceYearVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FinanceYearVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinanceYearVm>(<any>null);
    }

    createFinanceYear(command: CreateFinanceYearCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/FinanceYears";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFinanceYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFinanceYear(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFinanceYear(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    updateFinanceYear(id: string, command: UpdateFinanceYearCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FinanceYears/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateFinanceYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFinanceYear(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateFinanceYear(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteFinanceYear(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FinanceYears/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteFinanceYear(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteFinanceYear(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteFinanceYear(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IGeneralLedgersClient {
    generalLedgers(customerId: string | undefined): Observable<GeneralLedgerVm>;
    createGeneralLedger(command: CreateGeneralLedgerCommand): Observable<string>;
    glMaxIdByCustomerId(customerId: string): Observable<number>;
    generalLedgersLov(customerId: string): Observable<GeneralLedgerLovVm>;
    generalLedgerByGlIdCustomerAndCustomerId(customerId: string, id: number): Observable<GeneralLedgerDto>;
    updateGeneralLedger(id: string, command: UpdateGeneralLedgerCommand): Observable<FileResponse>;
    deleteGeneralLedger(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class GeneralLedgersClient implements IGeneralLedgersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    generalLedgers(customerId: string | undefined): Observable<GeneralLedgerVm> {
        let url_ = this.baseUrl + "/api/GeneralLedgers?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralLedgers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralLedgers(<any>response_);
                } catch (e) {
                    return <Observable<GeneralLedgerVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralLedgerVm>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralLedgers(response: HttpResponseBase): Observable<GeneralLedgerVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralLedgerVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralLedgerVm>(<any>null);
    }

    createGeneralLedger(command: CreateGeneralLedgerCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/GeneralLedgers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGeneralLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGeneralLedger(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGeneralLedger(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    glMaxIdByCustomerId(customerId: string): Observable<number> {
        let url_ = this.baseUrl + "/api/GeneralLedgers/GlMaxIdByCustomerId{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGlMaxIdByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGlMaxIdByCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGlMaxIdByCustomerId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    generalLedgersLov(customerId: string): Observable<GeneralLedgerLovVm> {
        let url_ = this.baseUrl + "/api/GeneralLedgers/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralLedgersLov(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralLedgersLov(<any>response_);
                } catch (e) {
                    return <Observable<GeneralLedgerLovVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralLedgerLovVm>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralLedgersLov(response: HttpResponseBase): Observable<GeneralLedgerLovVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralLedgerLovVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralLedgerLovVm>(<any>null);
    }

    generalLedgerByGlIdCustomerAndCustomerId(customerId: string, id: number): Observable<GeneralLedgerDto> {
        let url_ = this.baseUrl + "/api/GeneralLedgers/GeneralLedgerByGlIdCustomerAndCustomerId/{customerId}/{id}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGeneralLedgerByGlIdCustomerAndCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGeneralLedgerByGlIdCustomerAndCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<GeneralLedgerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GeneralLedgerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGeneralLedgerByGlIdCustomerAndCustomerId(response: HttpResponseBase): Observable<GeneralLedgerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralLedgerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GeneralLedgerDto>(<any>null);
    }

    updateGeneralLedger(id: string, command: UpdateGeneralLedgerCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/GeneralLedgers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGeneralLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGeneralLedger(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGeneralLedger(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteGeneralLedger(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/GeneralLedgers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGeneralLedger(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGeneralLedger(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGeneralLedger(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IMainAccountsClient {
    mainAccounts(customerId: string | undefined): Observable<MainAccountVm>;
    mainAccount(mainAccountIdByCustomer: number | undefined, customerId: string | undefined): Observable<MainAccountDto>;
    createMainAccount(command: CreateMainAccountCommand): Observable<string>;
    maxMainAccountIdByCustomer(customerId: string, id: number): Observable<number>;
    updateMainAccount(id: string, command: UpdateMainAccountCommand): Observable<FileResponse>;
    deleteMainAccount(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class MainAccountsClient implements IMainAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    mainAccounts(customerId: string | undefined): Observable<MainAccountVm> {
        let url_ = this.baseUrl + "/api/MainAccounts/customerId?";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMainAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMainAccounts(<any>response_);
                } catch (e) {
                    return <Observable<MainAccountVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainAccountVm>><any>_observableThrow(response_);
        }));
    }

    protected processMainAccounts(response: HttpResponseBase): Observable<MainAccountVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainAccountVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainAccountVm>(<any>null);
    }

    mainAccount(mainAccountIdByCustomer: number | undefined, customerId: string | undefined): Observable<MainAccountDto> {
        let url_ = this.baseUrl + "/api/MainAccounts?";
        if (mainAccountIdByCustomer === null)
            throw new Error("The parameter 'mainAccountIdByCustomer' cannot be null.");
        else if (mainAccountIdByCustomer !== undefined)
            url_ += "mainAccountIdByCustomer=" + encodeURIComponent("" + mainAccountIdByCustomer) + "&"; 
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMainAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMainAccount(<any>response_);
                } catch (e) {
                    return <Observable<MainAccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainAccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processMainAccount(response: HttpResponseBase): Observable<MainAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainAccountDto>(<any>null);
    }

    createMainAccount(command: CreateMainAccountCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/MainAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMainAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMainAccount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateMainAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    maxMainAccountIdByCustomer(customerId: string, id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/MainAccounts/MaxMainAccountIdByCustomer/{customerId}/{id}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaxMainAccountIdByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxMainAccountIdByCustomer(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxMainAccountIdByCustomer(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateMainAccount(id: string, command: UpdateMainAccountCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/MainAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMainAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMainAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMainAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteMainAccount(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/MainAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMainAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMainAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMainAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoItemsClient {
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TodosVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodosVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITotalAccountsClient {
    totalAccounts(customerId: string): Observable<TotalAccountVm>;
    totalAccount(mainAccountIdByCustomer: number | undefined, customerId: string | undefined): Observable<TotalAccountDto>;
    createTotalAccount(command: CreateTotalAccountCommand): Observable<string>;
    maxTotalAccountIdByCustomer(customerId: string, id: number): Observable<number>;
    updateTotalAccount(id: string, command: UpdateTotalAccountCommand): Observable<FileResponse>;
    deleteTotalAccount(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TotalAccountsClient implements ITotalAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    totalAccounts(customerId: string): Observable<TotalAccountVm> {
        let url_ = this.baseUrl + "/api/TotalAccounts/{customerId}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTotalAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTotalAccounts(<any>response_);
                } catch (e) {
                    return <Observable<TotalAccountVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TotalAccountVm>><any>_observableThrow(response_);
        }));
    }

    protected processTotalAccounts(response: HttpResponseBase): Observable<TotalAccountVm> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TotalAccountVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TotalAccountVm>(<any>null);
    }

    totalAccount(mainAccountIdByCustomer: number | undefined, customerId: string | undefined): Observable<TotalAccountDto> {
        let url_ = this.baseUrl + "/api/TotalAccounts?";
        if (mainAccountIdByCustomer === null)
            throw new Error("The parameter 'mainAccountIdByCustomer' cannot be null.");
        else if (mainAccountIdByCustomer !== undefined)
            url_ += "mainAccountIdByCustomer=" + encodeURIComponent("" + mainAccountIdByCustomer) + "&"; 
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "customerId=" + encodeURIComponent("" + customerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTotalAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTotalAccount(<any>response_);
                } catch (e) {
                    return <Observable<TotalAccountDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TotalAccountDto>><any>_observableThrow(response_);
        }));
    }

    protected processTotalAccount(response: HttpResponseBase): Observable<TotalAccountDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TotalAccountDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TotalAccountDto>(<any>null);
    }

    createTotalAccount(command: CreateTotalAccountCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/TotalAccounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTotalAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTotalAccount(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTotalAccount(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    maxTotalAccountIdByCustomer(customerId: string, id: number): Observable<number> {
        let url_ = this.baseUrl + "/api/TotalAccounts/{customerId}/{id}";
        if (customerId === undefined || customerId === null)
            throw new Error("The parameter 'customerId' must be defined.");
        url_ = url_.replace("{customerId}", encodeURIComponent("" + customerId)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMaxTotalAccountIdByCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaxTotalAccountIdByCustomer(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processMaxTotalAccountIdByCustomer(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateTotalAccount(id: string, command: UpdateTotalAccountCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TotalAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTotalAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTotalAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTotalAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    deleteTotalAccount(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TotalAccounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTotalAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTotalAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTotalAccount(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class BondVm implements IBondVm {
    lists?: BondDto[] | undefined;

    constructor(data?: IBondVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(BondDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BondVm {
        data = typeof data === 'object' ? data : {};
        let result = new BondVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBondVm {
    lists?: BondDto[] | undefined;
}

export class BondDto implements IBondDto {
    id?: string;
    bondUserId?: number;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    isActive?: boolean;
    cusId?: string;

    constructor(data?: IBondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.bondUserId = data["bondUserId"];
            this.intialSNo = data["intialSNo"];
            this.bondNameAr = data["bondNameAr"];
            this.bondNameEn = data["bondNameEn"];
            this.isActive = data["isActive"];
            this.cusId = data["cusId"];
        }
    }

    static fromJS(data: any): BondDto {
        data = typeof data === 'object' ? data : {};
        let result = new BondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bondUserId"] = this.bondUserId;
        data["intialSNo"] = this.intialSNo;
        data["bondNameAr"] = this.bondNameAr;
        data["bondNameEn"] = this.bondNameEn;
        data["isActive"] = this.isActive;
        data["cusId"] = this.cusId;
        return data; 
    }
}

export interface IBondDto {
    id?: string;
    bondUserId?: number;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    isActive?: boolean;
    cusId?: string;
}

export class BondDailyTransactionDto implements IBondDailyTransactionDto {
    bondId?: string;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    bondMaxSNo?: number;

    constructor(data?: IBondDailyTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bondId = data["bondId"];
            this.bondNameAr = data["bondNameAr"];
            this.bondNameEn = data["bondNameEn"];
            this.bondMaxSNo = data["bondMaxSNo"];
        }
    }

    static fromJS(data: any): BondDailyTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BondDailyTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bondId"] = this.bondId;
        data["bondNameAr"] = this.bondNameAr;
        data["bondNameEn"] = this.bondNameEn;
        data["bondMaxSNo"] = this.bondMaxSNo;
        return data; 
    }
}

export interface IBondDailyTransactionDto {
    bondId?: string;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    bondMaxSNo?: number;
}

export class CreateBondCommand implements ICreateBondCommand {
    bondUserId?: number;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    customerId?: string;

    constructor(data?: ICreateBondCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bondUserId = data["bondUserId"];
            this.intialSNo = data["intialSNo"];
            this.bondNameAr = data["bondNameAr"];
            this.bondNameEn = data["bondNameEn"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CreateBondCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBondCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bondUserId"] = this.bondUserId;
        data["intialSNo"] = this.intialSNo;
        data["bondNameAr"] = this.bondNameAr;
        data["bondNameEn"] = this.bondNameEn;
        data["customerId"] = this.customerId;
        return data; 
    }
}

export interface ICreateBondCommand {
    bondUserId?: number;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
    customerId?: string;
}

export class UpdateBondCommand implements IUpdateBondCommand {
    id?: string;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;

    constructor(data?: IUpdateBondCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.intialSNo = data["intialSNo"];
            this.bondNameAr = data["bondNameAr"];
            this.bondNameEn = data["bondNameEn"];
        }
    }

    static fromJS(data: any): UpdateBondCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBondCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["intialSNo"] = this.intialSNo;
        data["bondNameAr"] = this.bondNameAr;
        data["bondNameEn"] = this.bondNameEn;
        return data; 
    }
}

export interface IUpdateBondCommand {
    id?: string;
    intialSNo?: number;
    bondNameAr?: string | undefined;
    bondNameEn?: string | undefined;
}

export class CustomerVm implements ICustomerVm {
    lists?: CustomerDto[] | undefined;

    constructor(data?: ICustomerVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(CustomerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerVm {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerVm {
    lists?: CustomerDto[] | undefined;
}

export class CustomerDto implements ICustomerDto {
    id?: string;
    customerId?: number;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.customerNameAr = data["customerNameAr"];
            this.customerNameEn = data["customerNameEn"];
            this.taxNo = data["taxNo"];
            this.faxNo = data["faxNo"];
            this.phoneNo = data["phoneNo"];
            this.mobileNo1 = data["mobileNo1"];
            this.mobileNo2 = data["mobileNo2"];
            this.country = data["country"];
            this.city = data["city"];
            this.address = data["address"];
            this.email = data["email"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["customerNameAr"] = this.customerNameAr;
        data["customerNameEn"] = this.customerNameEn;
        data["taxNo"] = this.taxNo;
        data["faxNo"] = this.faxNo;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo1"] = this.mobileNo1;
        data["mobileNo2"] = this.mobileNo2;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["email"] = this.email;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICustomerDto {
    id?: string;
    customerId?: number;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
    isActive?: boolean;
}

export class CustomerLovVm implements ICustomerLovVm {
    lists?: CustomerLovDto[] | undefined;

    constructor(data?: ICustomerLovVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(CustomerLovDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerLovVm {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLovVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerLovVm {
    lists?: CustomerLovDto[] | undefined;
}

export class CustomerLovDto implements ICustomerLovDto {
    id?: string;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;

    constructor(data?: ICustomerLovDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerNameAr = data["customerNameAr"];
            this.customerNameEn = data["customerNameEn"];
        }
    }

    static fromJS(data: any): CustomerLovDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLovDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerNameAr"] = this.customerNameAr;
        data["customerNameEn"] = this.customerNameEn;
        return data; 
    }
}

export interface ICustomerLovDto {
    id?: string;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
}

export class CreateCustomerCommand implements ICreateCustomerCommand {
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;

    constructor(data?: ICreateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerNameAr = data["customerNameAr"];
            this.customerNameEn = data["customerNameEn"];
            this.taxNo = data["taxNo"];
            this.faxNo = data["faxNo"];
            this.phoneNo = data["phoneNo"];
            this.mobileNo1 = data["mobileNo1"];
            this.mobileNo2 = data["mobileNo2"];
            this.country = data["country"];
            this.city = data["city"];
            this.address = data["address"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerNameAr"] = this.customerNameAr;
        data["customerNameEn"] = this.customerNameEn;
        data["taxNo"] = this.taxNo;
        data["faxNo"] = this.faxNo;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo1"] = this.mobileNo1;
        data["mobileNo2"] = this.mobileNo2;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["email"] = this.email;
        return data; 
    }
}

export interface ICreateCustomerCommand {
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
}

export class UpdateCustomerCommand implements IUpdateCustomerCommand {
    id?: string;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;

    constructor(data?: IUpdateCustomerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerNameAr = data["customerNameAr"];
            this.customerNameEn = data["customerNameEn"];
            this.taxNo = data["taxNo"];
            this.faxNo = data["faxNo"];
            this.phoneNo = data["phoneNo"];
            this.mobileNo1 = data["mobileNo1"];
            this.mobileNo2 = data["mobileNo2"];
            this.country = data["country"];
            this.city = data["city"];
            this.address = data["address"];
            this.email = data["email"];
        }
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerNameAr"] = this.customerNameAr;
        data["customerNameEn"] = this.customerNameEn;
        data["taxNo"] = this.taxNo;
        data["faxNo"] = this.faxNo;
        data["phoneNo"] = this.phoneNo;
        data["mobileNo1"] = this.mobileNo1;
        data["mobileNo2"] = this.mobileNo2;
        data["country"] = this.country;
        data["city"] = this.city;
        data["address"] = this.address;
        data["email"] = this.email;
        return data; 
    }
}

export interface IUpdateCustomerCommand {
    id?: string;
    customerNameAr?: string | undefined;
    customerNameEn?: string | undefined;
    taxNo?: string | undefined;
    faxNo?: string | undefined;
    phoneNo?: string | undefined;
    mobileNo1?: string | undefined;
    mobileNo2?: string | undefined;
    country?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    email?: string | undefined;
}

export class CreateDailyTransactionCommand implements ICreateDailyTransactionCommand {
    dailyTransactionIdByCustomer?: number;
    customerId?: string;
    bondId?: string;
    dailyTransactionBondSNo?: number;
    dailyTransactionDate?: Date;
    dailyTransactionMonth?: number;
    dailyTransactionYear?: number;
    dailyTransactionDetailsList?: DailyTransactionDetailsDto[] | undefined;

    constructor(data?: ICreateDailyTransactionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dailyTransactionIdByCustomer = data["dailyTransactionIdByCustomer"];
            this.customerId = data["customerId"];
            this.bondId = data["bondId"];
            this.dailyTransactionBondSNo = data["dailyTransactionBondSNo"];
            this.dailyTransactionDate = data["dailyTransactionDate"] ? new Date(data["dailyTransactionDate"].toString()) : <any>undefined;
            this.dailyTransactionMonth = data["dailyTransactionMonth"];
            this.dailyTransactionYear = data["dailyTransactionYear"];
            if (Array.isArray(data["dailyTransactionDetailsList"])) {
                this.dailyTransactionDetailsList = [] as any;
                for (let item of data["dailyTransactionDetailsList"])
                    this.dailyTransactionDetailsList!.push(DailyTransactionDetailsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateDailyTransactionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDailyTransactionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyTransactionIdByCustomer"] = this.dailyTransactionIdByCustomer;
        data["customerId"] = this.customerId;
        data["bondId"] = this.bondId;
        data["dailyTransactionBondSNo"] = this.dailyTransactionBondSNo;
        data["dailyTransactionDate"] = this.dailyTransactionDate ? this.dailyTransactionDate.toISOString() : <any>undefined;
        data["dailyTransactionMonth"] = this.dailyTransactionMonth;
        data["dailyTransactionYear"] = this.dailyTransactionYear;
        if (Array.isArray(this.dailyTransactionDetailsList)) {
            data["dailyTransactionDetailsList"] = [];
            for (let item of this.dailyTransactionDetailsList)
                data["dailyTransactionDetailsList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateDailyTransactionCommand {
    dailyTransactionIdByCustomer?: number;
    customerId?: string;
    bondId?: string;
    dailyTransactionBondSNo?: number;
    dailyTransactionDate?: Date;
    dailyTransactionMonth?: number;
    dailyTransactionYear?: number;
    dailyTransactionDetailsList?: DailyTransactionDetailsDto[] | undefined;
}

export class DailyTransactionDetailsDto implements IDailyTransactionDetailsDto {
    dailyTransactionDebitAmount?: number;
    dailyTransactionCreditAmount?: number;
    dailyTransactionDescription?: string | undefined;
    detailAccountId?: string;
    totalAccountId?: string;
    mainAccountId?: string;
    generalLedgerId?: string;

    constructor(data?: IDailyTransactionDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dailyTransactionDebitAmount = data["dailyTransactionDebitAmount"];
            this.dailyTransactionCreditAmount = data["dailyTransactionCreditAmount"];
            this.dailyTransactionDescription = data["dailyTransactionDescription"];
            this.detailAccountId = data["detailAccountId"];
            this.totalAccountId = data["totalAccountId"];
            this.mainAccountId = data["mainAccountId"];
            this.generalLedgerId = data["generalLedgerId"];
        }
    }

    static fromJS(data: any): DailyTransactionDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyTransactionDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dailyTransactionDebitAmount"] = this.dailyTransactionDebitAmount;
        data["dailyTransactionCreditAmount"] = this.dailyTransactionCreditAmount;
        data["dailyTransactionDescription"] = this.dailyTransactionDescription;
        data["detailAccountId"] = this.detailAccountId;
        data["totalAccountId"] = this.totalAccountId;
        data["mainAccountId"] = this.mainAccountId;
        data["generalLedgerId"] = this.generalLedgerId;
        return data; 
    }
}

export interface IDailyTransactionDetailsDto {
    dailyTransactionDebitAmount?: number;
    dailyTransactionCreditAmount?: number;
    dailyTransactionDescription?: string | undefined;
    detailAccountId?: string;
    totalAccountId?: string;
    mainAccountId?: string;
    generalLedgerId?: string;
}

export class DetailAccountVm implements IDetailAccountVm {
    lists?: DetailAccountDto[] | undefined;

    constructor(data?: IDetailAccountVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(DetailAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DetailAccountVm {
        data = typeof data === 'object' ? data : {};
        let result = new DetailAccountVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDetailAccountVm {
    lists?: DetailAccountDto[] | undefined;
}

export class DetailAccountDto implements IDetailAccountDto {
    id?: string;
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    totalAccountNameAr?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;
    totalAccountIdByCustomer?: number;
    isActive?: boolean;

    constructor(data?: IDetailAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.detailAccountIdByCustomer = data["detailAccountIdByCustomer"];
            this.detailAccountNameAr = data["detailAccountNameAr"];
            this.detailAccountNameEn = data["detailAccountNameEn"];
            this.totalAccountNameAr = data["totalAccountNameAr"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
            this.mainAccountId = data["mainAccountId"];
            this.totalAccountId = data["totalAccountId"];
            this.totalAccountIdByCustomer = data["totalAccountIdByCustomer"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): DetailAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new DetailAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detailAccountIdByCustomer"] = this.detailAccountIdByCustomer;
        data["detailAccountNameAr"] = this.detailAccountNameAr;
        data["detailAccountNameEn"] = this.detailAccountNameEn;
        data["totalAccountNameAr"] = this.totalAccountNameAr;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        data["mainAccountId"] = this.mainAccountId;
        data["totalAccountId"] = this.totalAccountId;
        data["totalAccountIdByCustomer"] = this.totalAccountIdByCustomer;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IDetailAccountDto {
    id?: string;
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    totalAccountNameAr?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;
    totalAccountIdByCustomer?: number;
    isActive?: boolean;
}

export class DetailAccountDetailsVm implements IDetailAccountDetailsVm {
    id?: string;
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;
    isActive?: boolean;

    constructor(data?: IDetailAccountDetailsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.detailAccountIdByCustomer = data["detailAccountIdByCustomer"];
            this.detailAccountNameAr = data["detailAccountNameAr"];
            this.detailAccountNameEn = data["detailAccountNameEn"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
            this.mainAccountId = data["mainAccountId"];
            this.totalAccountId = data["totalAccountId"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): DetailAccountDetailsVm {
        data = typeof data === 'object' ? data : {};
        let result = new DetailAccountDetailsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detailAccountIdByCustomer"] = this.detailAccountIdByCustomer;
        data["detailAccountNameAr"] = this.detailAccountNameAr;
        data["detailAccountNameEn"] = this.detailAccountNameEn;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        data["mainAccountId"] = this.mainAccountId;
        data["totalAccountId"] = this.totalAccountId;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IDetailAccountDetailsVm {
    id?: string;
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;
    isActive?: boolean;
}

export class CreateDetailAccountCommand implements ICreateDetailAccountCommand {
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;

    constructor(data?: ICreateDetailAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.detailAccountIdByCustomer = data["detailAccountIdByCustomer"];
            this.detailAccountNameAr = data["detailAccountNameAr"];
            this.detailAccountNameEn = data["detailAccountNameEn"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
            this.mainAccountId = data["mainAccountId"];
            this.totalAccountId = data["totalAccountId"];
        }
    }

    static fromJS(data: any): CreateDetailAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDetailAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detailAccountIdByCustomer"] = this.detailAccountIdByCustomer;
        data["detailAccountNameAr"] = this.detailAccountNameAr;
        data["detailAccountNameEn"] = this.detailAccountNameEn;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        data["mainAccountId"] = this.mainAccountId;
        data["totalAccountId"] = this.totalAccountId;
        return data; 
    }
}

export interface ICreateDetailAccountCommand {
    detailAccountIdByCustomer?: number;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    totalAccountId?: string;
}

export class UpdateDetailAccountCommand implements IUpdateDetailAccountCommand {
    id?: string;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;

    constructor(data?: IUpdateDetailAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.detailAccountNameAr = data["detailAccountNameAr"];
            this.detailAccountNameEn = data["detailAccountNameEn"];
        }
    }

    static fromJS(data: any): UpdateDetailAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDetailAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["detailAccountNameAr"] = this.detailAccountNameAr;
        data["detailAccountNameEn"] = this.detailAccountNameEn;
        return data; 
    }
}

export interface IUpdateDetailAccountCommand {
    id?: string;
    detailAccountNameAr?: string | undefined;
    detailAccountNameEn?: string | undefined;
}

export class FinanceYearVm implements IFinanceYearVm {
    lists?: FinanceYearDto[] | undefined;

    constructor(data?: IFinanceYearVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(FinanceYearDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FinanceYearVm {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceYearVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFinanceYearVm {
    lists?: FinanceYearDto[] | undefined;
}

export class FinanceYearDto implements IFinanceYearDto {
    id?: string;
    year?: number;
    cusId?: string;
    customerId?: number;
    customerNameAr?: string | undefined;

    constructor(data?: IFinanceYearDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.year = data["year"];
            this.cusId = data["cusId"];
            this.customerId = data["customerId"];
            this.customerNameAr = data["customerNameAr"];
        }
    }

    static fromJS(data: any): FinanceYearDto {
        data = typeof data === 'object' ? data : {};
        let result = new FinanceYearDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["year"] = this.year;
        data["cusId"] = this.cusId;
        data["customerId"] = this.customerId;
        data["customerNameAr"] = this.customerNameAr;
        return data; 
    }
}

export interface IFinanceYearDto {
    id?: string;
    year?: number;
    cusId?: string;
    customerId?: number;
    customerNameAr?: string | undefined;
}

export class CreateFinanceYearCommand implements ICreateFinanceYearCommand {
    year?: number;
    customerId?: string;

    constructor(data?: ICreateFinanceYearCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.year = data["year"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CreateFinanceYearCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFinanceYearCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["customerId"] = this.customerId;
        return data; 
    }
}

export interface ICreateFinanceYearCommand {
    year?: number;
    customerId?: string;
}

export class UpdateFinanceYearCommand implements IUpdateFinanceYearCommand {
    id?: string;
    customerId?: string;
    year?: number;

    constructor(data?: IUpdateFinanceYearCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.year = data["year"];
        }
    }

    static fromJS(data: any): UpdateFinanceYearCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFinanceYearCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["year"] = this.year;
        return data; 
    }
}

export interface IUpdateFinanceYearCommand {
    id?: string;
    customerId?: string;
    year?: number;
}

export class GeneralLedgerVm implements IGeneralLedgerVm {
    lists?: GeneralLedgerDto[] | undefined;

    constructor(data?: IGeneralLedgerVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(GeneralLedgerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeneralLedgerVm {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGeneralLedgerVm {
    lists?: GeneralLedgerDto[] | undefined;
}

export class GeneralLedgerDto implements IGeneralLedgerDto {
    id?: string;
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
    customerId?: string;

    constructor(data?: IGeneralLedgerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.glIdByCustomer = data["glIdByCustomer"];
            this.glNameAr = data["glNameAr"];
            this.glNameEn = data["glNameEn"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): GeneralLedgerDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["glIdByCustomer"] = this.glIdByCustomer;
        data["glNameAr"] = this.glNameAr;
        data["glNameEn"] = this.glNameEn;
        data["customerId"] = this.customerId;
        return data; 
    }
}

export interface IGeneralLedgerDto {
    id?: string;
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
    customerId?: string;
}

export class GeneralLedgerLovVm implements IGeneralLedgerLovVm {
    lists?: GeneralLedgerLovDto[] | undefined;

    constructor(data?: IGeneralLedgerLovVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(GeneralLedgerLovDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GeneralLedgerLovVm {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerLovVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGeneralLedgerLovVm {
    lists?: GeneralLedgerLovDto[] | undefined;
}

export class GeneralLedgerLovDto implements IGeneralLedgerLovDto {
    id?: string;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;

    constructor(data?: IGeneralLedgerLovDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.glNameAr = data["glNameAr"];
            this.glNameEn = data["glNameEn"];
        }
    }

    static fromJS(data: any): GeneralLedgerLovDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerLovDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["glNameAr"] = this.glNameAr;
        data["glNameEn"] = this.glNameEn;
        return data; 
    }
}

export interface IGeneralLedgerLovDto {
    id?: string;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
}

export class CreateGeneralLedgerCommand implements ICreateGeneralLedgerCommand {
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
    customerId?: string;

    constructor(data?: ICreateGeneralLedgerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.glIdByCustomer = data["glIdByCustomer"];
            this.glNameAr = data["glNameAr"];
            this.glNameEn = data["glNameEn"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CreateGeneralLedgerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGeneralLedgerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glIdByCustomer"] = this.glIdByCustomer;
        data["glNameAr"] = this.glNameAr;
        data["glNameEn"] = this.glNameEn;
        data["customerId"] = this.customerId;
        return data; 
    }
}

export interface ICreateGeneralLedgerCommand {
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
    customerId?: string;
}

export class UpdateGeneralLedgerCommand implements IUpdateGeneralLedgerCommand {
    id?: string;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;

    constructor(data?: IUpdateGeneralLedgerCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.glNameAr = data["glNameAr"];
            this.glNameEn = data["glNameEn"];
        }
    }

    static fromJS(data: any): UpdateGeneralLedgerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGeneralLedgerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["glNameAr"] = this.glNameAr;
        data["glNameEn"] = this.glNameEn;
        return data; 
    }
}

export interface IUpdateGeneralLedgerCommand {
    id?: string;
    glNameAr?: string | undefined;
    glNameEn?: string | undefined;
}

export class MainAccountVm implements IMainAccountVm {
    lists?: MainAccountDto[] | undefined;

    constructor(data?: IMainAccountVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(MainAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MainAccountVm {
        data = typeof data === 'object' ? data : {};
        let result = new MainAccountVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMainAccountVm {
    lists?: MainAccountDto[] | undefined;
}

export class MainAccountDto implements IMainAccountDto {
    id?: string;
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    isActive?: boolean;

    constructor(data?: IMainAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mainAccountIdByCustomer = data["mainAccountIdByCustomer"];
            this.mainAccountNameAr = data["mainAccountNameAr"];
            this.mainAccountNameEn = data["mainAccountNameEn"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
            this.glIdByCustomer = data["glIdByCustomer"];
            this.glNameAr = data["glNameAr"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): MainAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new MainAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mainAccountIdByCustomer"] = this.mainAccountIdByCustomer;
        data["mainAccountNameAr"] = this.mainAccountNameAr;
        data["mainAccountNameEn"] = this.mainAccountNameEn;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        data["glIdByCustomer"] = this.glIdByCustomer;
        data["glNameAr"] = this.glNameAr;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IMainAccountDto {
    id?: string;
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    glIdByCustomer?: number;
    glNameAr?: string | undefined;
    isActive?: boolean;
}

export class CreateMainAccountCommand implements ICreateMainAccountCommand {
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;

    constructor(data?: ICreateMainAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mainAccountIdByCustomer = data["mainAccountIdByCustomer"];
            this.mainAccountNameAr = data["mainAccountNameAr"];
            this.mainAccountNameEn = data["mainAccountNameEn"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
        }
    }

    static fromJS(data: any): CreateMainAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMainAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mainAccountIdByCustomer"] = this.mainAccountIdByCustomer;
        data["mainAccountNameAr"] = this.mainAccountNameAr;
        data["mainAccountNameEn"] = this.mainAccountNameEn;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        return data; 
    }
}

export interface ICreateMainAccountCommand {
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
}

export class UpdateMainAccountCommand implements IUpdateMainAccountCommand {
    id?: string;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;

    constructor(data?: IUpdateMainAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mainAccountNameAr = data["mainAccountNameAr"];
            this.mainAccountNameEn = data["mainAccountNameEn"];
        }
    }

    static fromJS(data: any): UpdateMainAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMainAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mainAccountNameAr"] = this.mainAccountNameAr;
        data["mainAccountNameEn"] = this.mainAccountNameEn;
        return data; 
    }
}

export interface IUpdateMainAccountCommand {
    id?: string;
    mainAccountNameAr?: string | undefined;
    mainAccountNameEn?: string | undefined;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.listId = data["listId"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            this.done = data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.listId = data["listId"];
            this.priority = data["priority"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.listId = data["listId"];
            this.title = data["title"];
            this.done = data["done"];
            this.priority = data["priority"];
            this.note = data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.title = data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class TotalAccountVm implements ITotalAccountVm {
    lists?: TotalAccountDto[] | undefined;

    constructor(data?: ITotalAccountVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["lists"])) {
                this.lists = [] as any;
                for (let item of data["lists"])
                    this.lists!.push(TotalAccountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TotalAccountVm {
        data = typeof data === 'object' ? data : {};
        let result = new TotalAccountVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITotalAccountVm {
    lists?: TotalAccountDto[] | undefined;
}

export class TotalAccountDto implements ITotalAccountDto {
    id?: string;
    totalAccountIdByCustomer?: number;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    isClose?: boolean;
    isActive?: boolean;

    constructor(data?: ITotalAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.totalAccountIdByCustomer = data["totalAccountIdByCustomer"];
            this.totalAccountNameAr = data["totalAccountNameAr"];
            this.totalAccountNameEn = data["totalAccountNameEn"];
            this.customerId = data["customerId"];
            this.generalLeadgerId = data["generalLeadgerId"];
            this.mainAccountId = data["mainAccountId"];
            this.mainAccountIdByCustomer = data["mainAccountIdByCustomer"];
            this.mainAccountNameAr = data["mainAccountNameAr"];
            this.isClose = data["isClose"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): TotalAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new TotalAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalAccountIdByCustomer"] = this.totalAccountIdByCustomer;
        data["totalAccountNameAr"] = this.totalAccountNameAr;
        data["totalAccountNameEn"] = this.totalAccountNameEn;
        data["customerId"] = this.customerId;
        data["generalLeadgerId"] = this.generalLeadgerId;
        data["mainAccountId"] = this.mainAccountId;
        data["mainAccountIdByCustomer"] = this.mainAccountIdByCustomer;
        data["mainAccountNameAr"] = this.mainAccountNameAr;
        data["isClose"] = this.isClose;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ITotalAccountDto {
    id?: string;
    totalAccountIdByCustomer?: number;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    customerId?: string;
    generalLeadgerId?: string;
    mainAccountId?: string;
    mainAccountIdByCustomer?: number;
    mainAccountNameAr?: string | undefined;
    isClose?: boolean;
    isActive?: boolean;
}

export class CreateTotalAccountCommand implements ICreateTotalAccountCommand {
    totalAccountIdByCustomer?: number;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    customerId?: string;
    mainAccountId?: string;
    isClose?: boolean;

    constructor(data?: ICreateTotalAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalAccountIdByCustomer = data["totalAccountIdByCustomer"];
            this.totalAccountNameAr = data["totalAccountNameAr"];
            this.totalAccountNameEn = data["totalAccountNameEn"];
            this.customerId = data["customerId"];
            this.mainAccountId = data["mainAccountId"];
            this.isClose = data["isClose"];
        }
    }

    static fromJS(data: any): CreateTotalAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTotalAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAccountIdByCustomer"] = this.totalAccountIdByCustomer;
        data["totalAccountNameAr"] = this.totalAccountNameAr;
        data["totalAccountNameEn"] = this.totalAccountNameEn;
        data["customerId"] = this.customerId;
        data["mainAccountId"] = this.mainAccountId;
        data["isClose"] = this.isClose;
        return data; 
    }
}

export interface ICreateTotalAccountCommand {
    totalAccountIdByCustomer?: number;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    customerId?: string;
    mainAccountId?: string;
    isClose?: boolean;
}

export class UpdateTotalAccountCommand implements IUpdateTotalAccountCommand {
    id?: string;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    isClose?: boolean;

    constructor(data?: IUpdateTotalAccountCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.totalAccountNameAr = data["totalAccountNameAr"];
            this.totalAccountNameEn = data["totalAccountNameEn"];
            this.isClose = data["isClose"];
        }
    }

    static fromJS(data: any): UpdateTotalAccountCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTotalAccountCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["totalAccountNameAr"] = this.totalAccountNameAr;
        data["totalAccountNameEn"] = this.totalAccountNameEn;
        data["isClose"] = this.isClose;
        return data; 
    }
}

export interface IUpdateTotalAccountCommand {
    id?: string;
    totalAccountNameAr?: string | undefined;
    totalAccountNameEn?: string | undefined;
    isClose?: boolean;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.temperatureC = data["temperatureC"];
            this.temperatureF = data["temperatureF"];
            this.summary = data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}